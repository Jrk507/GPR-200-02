float merge(float d1, float d2)//combines distance fields
{
	return min(d1, d2);
}

vec2 translate(vec2 p, vec2 t)//used to return a starting size for the Distance field equations
{
	return p - t;
}


//////////////////////////////
// Distance field functions //
//////////////////////////////

float circleDist(vec2 p, float radius)
{
	return length(p) - radius;
}


float boxDist(vec2 p, vec2 size, float radius)
{
	size -= vec2(radius);
	vec2 d = abs(p) - size;
  	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
}

float fillMask(float dist)//Make 
{
	return clamp(-dist, 0.0, 1.0);
}

float sceneDist(vec2 p)
{
	float b5 = boxDist(	translate(p, vec2(iMouse.xy)),vec2(45, 45), 10.0);
	float c4 = circleDist(translate(p, vec2(50, 100)), 30.0);
	float a = merge(b5, c4);
	
	float m = (a);
	
	return m;
}


float shadow(vec2 p, vec2 pos, float radius)
{
	vec2 dir = normalize(pos - p);
	float dl = length(p - pos);
	
	// fraction of light visible, starts at one radius (second half added in the end);
	float lf = radius * dl;
	
	// distance traveled
	float dt = 0.01;

	for (int i = 0; i < 64; ++i)
	{				
		// distance to scene at current position
		float sd = sceneDist(p + dir * dt);

        // early out when this ray is guaranteed to be full shadow
        if (sd < -radius) 
            return 0.0;
        
		// width of cone-overlap at light
		// 0 in center, so 50% overlap: add one radius outside of loop to get total coverage
		// should be '(sd / dt) * dl', but '*dl' outside of loop
		lf = min(lf, sd / dt);
		
		// move ahead
		dt += max(1.0, abs(sd));
		if (dt > dl) return 1.0;
	}

	// multiply by dl to get the real projected overlap (moved out of loop)
	// add one radius, before between -radius and + radius
	// normalize to 1 ( / 2*radius)
	lf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);
//	lf = smoothstep(0.0, 1.0, lf);
	return lf;
}


struct lights
{
    vec2 position;
    vec4 color;
    float range;
    float radius;
    
};
    void setLights(inout lights light, in vec2 center, vec4 color,float radius, float range)//initialize our struct lights
{
    light.position = center;
    light.color = color;
    light.radius = radius;
    light.range = range;
}
vec4 drawLight(vec2 p, lights l ,float dist)
{
	// distance to light
	float ld = length(p - l.position);
	
	// out of range
	if (ld > l.range) return vec4(0.0);
	
	// shadow and falloff
	float shad = shadow(p, l.position, l.radius);
	float fall = (l.range - ld)/l.range;
	fall *= fall;
	float source = fillMask(circleDist(p - l.position, l.radius));
	return (shad * fall + source) * l.color;
}


float luminance(vec4 col)
{
	return 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;
}


void setLuminance(inout vec4 col, float lum)
{
	lum /= luminance(col);
	col *= lum;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	vec2 p = fragCoord.xy;
	vec2 c = iResolution.xy / 2.0;;
	float dist = sceneDist(p);
    lights lightOne;
    setLights(lightOne, vec2(256,144), vec4(0.55, 0.3, 0.5, 1.0), 5.0, 105.0);
    setLuminance(lightOne.color, 0.75);
	// gradient
	vec4 col = vec4(0.5, 0.5, 0.5, 1.0);
	// light
    col+= drawLight(p, lightOne, dist);
    col = mix(col, vec4(1.0, 0.4, 0.0, 1.0), fillMask(dist));
    fragColor = col;
}
