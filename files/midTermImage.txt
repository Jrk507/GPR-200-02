float fillMask(float dist)
{
	return clamp(-dist, 0.0, 1.0);
}

vec2 translate(vec2 p, vec2 t)
{
	return p - t;
}

float merge(float d1, float d2)
{
	return min(d1, d2);
}
/*Distance Fields*/
float circleDist(vec2 p, float radius)
{
	return length(p) - radius;
}


float boxDist(vec2 p, vec2 size, float radius)
{
	size -= vec2(radius);
	vec2 d = abs(p) - size;
  	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
}

/*Scene*/
float sceneDist(vec2 p)
{
	float b1 = boxDist(	translate(p, vec2(iMouse.xy)), 
                       vec2(120, 190), 	155.0);
	float c1 = circleDist(	translate(p, vec2(50, 100)), 	30.0);
	float a = merge(b1, c1);
	
	float m = a;
	
	return m;
}
/*Lighting and Shading*/
struct lights
{
    vec2 position;
    vec4 color;
    float lum;
    float range;
    float radius;
    
};
float shadow(vec2 p, vec2 pos, float radius)
{
	vec2 dir = normalize(pos - p);
	float dl = length(p - pos);
	
	// fraction of light visible, starts at one radius (second half added in the end);
	float lf = radius * dl;
	
	// distance traveled
	float dt = 0.01;

	for (int i = 0; i < 64; ++i)
	{				
		// distance to scene at current position
		float sd = sceneDist(p + dir * dt);

        // early out when this ray is guaranteed to be full shadow
        if (sd < -radius) 
            return 0.0;
        
		// width of cone-overlap at light
		// 0 in center, so 50% overlap: add one radius outside of loop to get total coverage
		// should be '(sd / dt) * dl', but '*dl' outside of loop
		lf = min(lf, sd / dt);
		
		// move ahead
		dt += max(1.0, abs(sd));
		if (dt > dl) break;
	}

	// multiply by dl to get the real projected overlap (moved out of loop)
	// add one radius, before between -radius and + radius
	// normalize to 1 ( / 2*radius)
	lf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);
	lf = smoothstep(0.0, 1.0, lf);
	return lf;
}



vec4 drawLight(vec2 p, lights l, float dist, float range)
{
	// distance to light
	float ld = length(p - l.position);
	
	// out of range
	if (ld > l.range) return vec4(0.0);
	
	// shadow and falloff
	float shad = shadow(p, l.position, l.radius);
	float fall = (l.range - ld)/l.range;
	fall *= fall;
	float source = fillMask(circleDist(p - l.position, l.radius));
	return (shad * fall + source) * l.color;
}

////////////////////////////////////////////////////////////////////////////////

    void setLights(out lights light, in vec2 center, float luminance, vec4 color,float radius)//initialize our struct lights
{
    light.position = center;
    light.lum = luminance;
    light.color = color;
    light.radius = radius;
}
void setLuminance(in lights l)
{

    l.lum /= 0.2126 * l.color.r + 0.7152 * l.color.g + 0.0722 * l.color.b;
	l.color *= l.lum;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 p = fragCoord.xy;
	vec2 c = iResolution.xy / 2.0;
    float dist = sceneDist(p);
    lights lightOne;
    setLights(lightOne, vec2(iResolution.y * (tan(iTime)) / 2.4, 50.0), 25.0, vec4(1.0,0.0,0.75,1.0), 35.0);
    setLuminance(lightOne);
    vec4 col = drawLight(p, lightOne, dist, 12.0);
    col = mix(col, vec4(1.0, 0.4, 0.0, 1.0), fillMask(dist));
    col *= vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(c - p)/iResolution.x);
    fragColor = col;
}